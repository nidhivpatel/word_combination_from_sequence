# -*- coding: utf-8 -*-
"""Picovoice_Screening_Question2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BejAmQ3aqRTc01H1fGJYmlNlFkWL3Wm-

Q2 [C, Python] A phoneme is a sound unit (similar to a character for text). We have an extensive pronunciation dictionary (think millions of words). Below is a snippet:
ABACUS AE B AH K AH S,
BOOK B UH K,
THEIR DH EH R,
THERE DH EH R,
TOMATO T AH M AA T OW,
TOMATO T AH M EY T OW
Given a sequence of phonemes as input (e.g. ["DH", "EH", "R", "DH", "EH", "R"]), find all the combinations of the words that can produce this sequence (e.g. [["THEIR", "THEIR"], ["THEIR", "THERE"], ["THERE", "THEIR"], ["THERE", "THERE"]]). You can preprocess the dictionary into a different data structure if needed.

Solution:

1. Preprocessing the Pronunciation Dictionary
-> The pronunciation dictionary is preprocessed into a defaultdict called to_words, where each key is a tuple of phonemes, and the value is a list of words that have that pronunciation.

-> This allows for O(1) lookups of words based on phoneme sequences.

2. Used DP approach to efficiently find all possible word combinations that match the input phoneme sequence.
-> A list sequences is used to store all possible word combinations for each substring of the phoneme sequence.

-> The algorithm iterates(backwards) from the end of the phoneme sequence to the start.

-> For each start position, it iterates over possible end positions to form candidate phoneme sequences.

-> If a candidate sequence exists in to_words, it combines the matching words with all valid sequences from sequences[end + 1].


The final result is stored in sequences[0], which contains all valid word combinations for the entire phoneme sequence.

Time Complexity:
1. Preprocessing: O(m1 * m2 * m3), where:

m1 = number of words in the dictionary,

m2 = average number of phoneme sequences per word,

m3 = average length of a phoneme sequence.
2. Dynamic Programming: O(nÂ² * W), where:

n = length of the input phoneme sequence,

W = maximum number of matching words for any phoneme sequence.

Space Complexity:
1. Preprocessing: The to_words dictionary requires O(m1 * m2 * m3) space.
2. Dynamic Programming: The sequences list stores all possible word combinations, which can grow exponentially in the worst case.
-> The space complexity is O(S), where S is the total number of valid word combinations.
"""

from typing import Sequence, List, Dict
from collections import defaultdict

# Pronunciation dictionary mapping words to their possible phoneme sequences
pronunciation_dict = {
    "ABACUS": [["AE", "B", "AH", "K", "AH", "S"]],
    "BOOK": [["B", "UH", "K"]],
    "THEIR": [["DH", "EH", "R"]],
    "THERE": [["DH", "EH", "R"]],
    "TOMATO": [["T", "AH", "M", "AA", "T", "OW"], ["T", "AH", "M", "EY", "T", "OW"]],
}

def find_word_combos_with_pronunciation(phonemes: Sequence[str]) -> Sequence[Sequence[str]]:
    # Create a map of: pronounciation -> word
    to_words = defaultdict(list)
    n = len(phonemes)
    for word, word_phonemes_list in pronunciation_dict.items(): # TC: O(length of dictionary)
        for word_phonemes in word_phonemes_list:
            pronounciation = tuple(word_phonemes) # Convert list to tuple for hashability
            to_words[pronounciation].append(word)

    # sequences[i] stores all possible sequences of words for phonemes[i, n - 1]
    sequences = [[]] * (n + 1)
    sequences[n] = [[]] # Base case: empty sequence at the end

    for start in range(n - 1, -1, -1): # Iterate from the end to the start | TC: O(square of length of input)
        seqs = []
        for end in range(start, n):
            candidate_pronc = tuple(phonemes[start: end + 1])
            if candidate_pronc in to_words:
                for candidate_word in to_words[candidate_pronc]:
                    for next_words in sequences[end + 1]:
                        seqs.append([candidate_word] + next_words)
        sequences[start] = seqs
    return sequences[0]

# Testcase 1
phonemes = ["AE", "B", "AH", "K", "AH", "S"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 2
phonemes = ["B", "UH", "K"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 3
phonemes = ["DH", "EH", "R"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 4
phonemes = ["DH", "EH", "R", "DH", "EH", "R"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 5
phonemes = ["T", "AH", "M", "AA", "T", "OW"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 6
phonemes = ["T", "AH", "M", "EY", "T", "OW"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)

# Testcase 7
phonemes = ["T", "AH", "M", "EY", "T", "OW", "T", "AH", "M", "AA", "T", "OW"]
result = find_word_combos_with_pronunciation(phonemes)
print(result)